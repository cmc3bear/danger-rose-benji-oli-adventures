name: üìã Library Feature Specification
description: Comprehensive specification for new library features using Spec-Driven Development
title: "feat: [Feature Name]"
labels: ["enhancement", "specification"]
assignees: []
body:
  - type: markdown
    attributes:
      value: |
        ## üéØ Feature Specification Template

        Use this template for **complex features, public APIs, or when specifications are needed**.
        For simple utilities or obvious implementations, create a regular feature request instead.

        This template follows the **Spec-Driven Development (SDD)** workflow documented in `CLAUDE.md`.

  - type: input
    id: protocol-reference
    attributes:
      label: üìã Python Protocol Reference
      description: Which protocol from `specs/interfaces/` does this feature implement? (if any)
      placeholder: "DataProcessor, ConfigurableClient, or None if not applicable"
    validations:
      required: false

  - type: textarea
    id: overview
    attributes:
      label: üìã Overview
      description: |
        **What**: One-sentence description of what this feature does
        **Why**: Business justification - why is this needed?
        **Who**: Target users - library consumers, CLI users, internal developers
      placeholder: |
        **What**: A data validation system that validates input data against configurable rules.
        **Why**: Library users need to validate data before processing to prevent errors.
        **Who**: Python developers using this library for data processing applications.
    validations:
      required: true

  - type: textarea
    id: acceptance-criteria
    attributes:
      label: ‚úÖ Acceptance Criteria
      description: Use "Given/When/Then" format for clear, testable criteria
      placeholder: |
        ### Core Functionality
        - [ ] **Given** a data validator with rules, **When** valid data is submitted, **Then** validation passes and returns success result
        - [ ] **Given** a data validator with rules, **When** invalid data is submitted, **Then** validation fails with detailed error information

        ### Edge Cases & Error Handling
        - [ ] **Given** no validation rules configured, **When** any data is validated, **Then** validation passes (permissive by default)
        - [ ] **Given** malformed validation rules, **When** validator is created, **Then** raises ValidationConfigError

        ### Performance & Quality
        - [ ] **Given** large datasets (10k+ records), **When** batch validation occurs, **Then** completes within 5 seconds
        - [ ] Test coverage: 90%+ for all new code
        - [ ] All public functions have docstrings with examples
        - [ ] Type hints for all function parameters and returns
    validations:
      required: true

  - type: textarea
    id: api-design
    attributes:
      label: üîß API Design
      description: Show the proposed public interface - function signatures, class structure, etc.
      render: python
      placeholder: |
        # Main public API
        def validate_data(data: Any, rules: Dict[str, Any]) -> ValidationResult:
            """Validate data against specified rules.

            Args:
                data: Input data to validate
                rules: Validation rules dictionary

            Returns:
                ValidationResult with success/failure details

            Raises:
                ValidationError: If rules are malformed
            """
            pass

        class DataValidator:
            """Configurable data validator."""

            def __init__(self, rules: Dict[str, Any], *, strict: bool = True):
                """Initialize validator with rules."""
                pass

            def validate(self, data: Any) -> ValidationResult:
                """Validate single data item."""
                pass
    validations:
      required: true

  - type: textarea
    id: test-scenarios
    attributes:
      label: üß™ Test Scenarios
      description: Key test cases that need to be implemented (happy path, edge cases, integration)
      render: python
      placeholder: |
        def test_validation_success_with_valid_data():
            """Test validation passes with conforming data."""
            # Arrange
            validator = DataValidator({"type": "string", "minLength": 2})
            data = "hello"

            # Act
            result = validator.validate(data)

            # Assert
            assert result.success is True
            assert result.errors == []

        def test_validation_failure_with_invalid_data():
            """Test validation fails with non-conforming data."""
            # Arrange - Act - Assert pattern

        @pytest.mark.slow
        def test_batch_validation_performance():
            """Test validation performance with large datasets."""
            # Performance test implementation
    validations:
      required: true

  - type: textarea
    id: usage-examples
    attributes:
      label: üìö Usage Examples
      description: Show how developers will use this feature in practice
      render: python
      placeholder: |
        # Basic usage
        from augint_library.validation import DataValidator

        validator = DataValidator({"type": "object", "required": ["name", "email"]})
        result = validator.validate({"name": "Alice", "email": "alice@example.com"})

        if result.success:
            print("Data is valid!")
        else:
            for error in result.errors:
                print(f"Error: {error['message']}")

        # Advanced usage
        batch_results = validator.validate_batch([data1, data2, data3])
    validations:
      required: true

  - type: textarea
    id: dependencies
    attributes:
      label: üîó Dependencies & Configuration
      description: New dependencies, environment variables, or configuration options required
      placeholder: |
        **Dependencies to add to pyproject.toml**:
        - `jsonschema>=4.0.0` (JSON Schema validation)
        - `pydantic>=2.0.0` (Model validation)

        **Environment Variables**:
        - `AUGINT_VALIDATION_MODE`: strict|permissive (default: strict)

        **Configuration Options**:
        - `validation_timeout`: Max validation time in seconds (default: 30)
    validations:
      required: false

  - type: textarea
    id: implementation-notes
    attributes:
      label: üéõÔ∏è Implementation Notes
      description: Special considerations, patterns to follow, or guidance for AI assistants
      placeholder: |
        **For AI Implementation**:
        1. Read the Protocol specification in `specs/interfaces/` first
        2. Write failing tests based on acceptance criteria before implementation
        3. Follow existing library patterns from `src/augint_library/`
        4. Use Google docstring format with examples
        5. Add `@pytest.mark.slow` for integration/performance tests

        **Key Patterns**:
        - Raise specific exceptions with clear error messages
        - Use type hints for all parameters and returns
        - Follow Arrange-Act-Assert test pattern
        - Ensure 90%+ test coverage for all new code
    validations:
      required: false

  - type: checkboxes
    id: checklist
    attributes:
      label: üìã Pre-Implementation Checklist
      description: Confirm these items before starting implementation
      options:
        - label: Feature requires Spec-Driven Development (complex/public API)
          required: true
        - label: Acceptance criteria are testable and complete
          required: true
        - label: API design follows library patterns and conventions
          required: true
        - label: Test scenarios cover happy path, edge cases, and integration
          required: true
        - label: Usage examples are clear and practical
          required: true
        - label: Dependencies and configuration requirements are documented
          required: false

  - type: markdown
    attributes:
      value: |
        ## üöÄ Next Steps

        After creating this issue:
        1. **Create Feature Branch**: `git checkout -b feat/issue-[number]-[description]`
        2. **Create Feature Specification**: Copy `specs/features/template.md` and fill in details from this issue
        3. **Implement with TDD**: Write failing tests first, then implement to pass tests
        4. **Quality Checks**: Run `make lint && make test && make security` before submitting PR
        5. **Submit PR**: Link to this issue with "closes #[issue-number]" in PR body

        See `CLAUDE.md` for complete Library Development Workflow guidance.
